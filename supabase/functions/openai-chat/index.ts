
import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.7.1';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Initialize Supabase client
const supabase = createClient(
  Deno.env.get('SUPABASE_URL') ?? '',
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
);

// Analyze search intent using OpenAI
async function analyzeSearchIntent(message: string, apiKey: string) {
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: `◊ê◊™◊î ◊û◊ï◊û◊ó◊î ◊ú◊†◊ô◊™◊ï◊ó ◊ë◊ß◊©◊ï◊™ ◊ó◊ô◊§◊ï◊© ◊ô◊î◊ú◊ï◊û◊ô◊ù. ◊†◊™◊ó ◊ê◊™ ◊î◊î◊ï◊ì◊¢◊î ◊ï◊ë◊ì◊ï◊ß ◊ê◊ù ◊ñ◊î ◊ó◊ô◊§◊ï◊© ◊ô◊î◊ú◊ï◊ù. ◊ê◊ù ◊õ◊ü, ◊ó◊ú◊• ◊ê◊™ ◊î◊ß◊®◊ô◊ò◊®◊ô◊ï◊†◊ô◊ù.
          
          ◊î◊ó◊ñ◊® ◊™◊©◊ï◊ë◊î ◊ë◊§◊ï◊®◊û◊ò JSON ◊ë◊ú◊ë◊ì:
          {
            "isSearchQuery": boolean,
            "criteria": {
              "shape": "string ◊ê◊ï null",
              "color": "string ◊ê◊ï null", 
              "clarity": "string ◊ê◊ï null",
              "weight_min": number ◊ê◊ï null,
              "weight_max": number ◊ê◊ï null,
              "price_min": number ◊ê◊ï null,
              "price_max": number ◊ê◊ï null
            },
            "customerInfo": {
              "name": "string ◊ê◊ï null",
              "phone": "string ◊ê◊ï null"
            }
          }`
        },
        {
          role: 'user',
          content: message
        }
      ],
      temperature: 0.1,
      max_tokens: 300,
    }),
  });

  if (!response.ok) {
    console.error('OpenAI analysis failed:', response.status);
    return { isSearchQuery: false, criteria: null, customerInfo: null };
  }

  const data = await response.json();
  try {
    return JSON.parse(data.choices[0].message.content);
  } catch (error) {
    console.error('Failed to parse search analysis:', error);
    return { isSearchQuery: false, criteria: null, customerInfo: null };
  }
}

// Process search matches and send notifications
async function processSearchMatches(criteria: any, allInventory: any[], searcherUserId: number) {
  console.log('üîç Processing search matches for criteria:', criteria);
  
  const userMatches = new Map();
  
  // Group diamonds by owner and calculate matches
  for (const diamond of allInventory) {
    const ownerId = diamond.owner_id || diamond.user_id;
    if (!ownerId || ownerId === searcherUserId) continue; // Skip searcher's own diamonds
    
    const matchResult = calculateMatch(diamond, criteria);
    if (matchResult.score > 0.3) { // Minimum 30% match threshold
      
      if (!userMatches.has(ownerId)) {
        userMatches.set(ownerId, []);
      }
      
      userMatches.get(ownerId).push({
        id: diamond.id,
        stock_number: diamond.stock_number,
        shape: diamond.shape,
        color: diamond.color,
        clarity: diamond.clarity,
        weight: diamond.weight,
        price_per_carat: diamond.price_per_carat,
        match_score: matchResult.score,
        match_reasons: matchResult.reasons
      });
    }
  }
  
  // Send notifications to owners with matches
  for (const [ownerId, matches] of userMatches) {
    if (matches.length > 0) {
      await sendMatchNotification(matches, criteria, ownerId);
    }
  }
  
  console.log(`üì® Sent match notifications to ${userMatches.size} diamond owners`);
}

// Calculate match score between diamond and search criteria
function calculateMatch(diamond: any, criteria: any): { score: number; reasons: string[] } {
  let score = 0;
  const reasons: string[] = [];
  let totalCriteria = 0;

  // Shape match (high importance)
  if (criteria.shape) {
    totalCriteria++;
    if (diamond.shape?.toLowerCase() === criteria.shape.toLowerCase()) {
      score += 0.3;
      reasons.push(`◊¶◊ï◊®◊î ◊ñ◊î◊î: ${criteria.shape}`);
    }
  }

  // Color match (high importance)
  if (criteria.color) {
    totalCriteria++;
    if (diamond.color === criteria.color) {
      score += 0.25;
      reasons.push(`◊¶◊ë◊¢ ◊ñ◊î◊î: ${criteria.color}`);
    } else if (isColorSimilar(diamond.color, criteria.color)) {
      score += 0.15;
      reasons.push(`◊¶◊ë◊¢ ◊ì◊ï◊û◊î: ${diamond.color} ~ ${criteria.color}`);
    }
  }

  // Clarity match
  if (criteria.clarity) {
    totalCriteria++;
    if (diamond.clarity === criteria.clarity) {
      score += 0.2;
      reasons.push(`◊ë◊î◊ô◊®◊ï◊™ ◊ñ◊î◊î: ${criteria.clarity}`);
    } else if (isClaritySimilar(diamond.clarity, criteria.clarity)) {
      score += 0.1;
      reasons.push(`◊ë◊î◊ô◊®◊ï◊™ ◊ì◊ï◊û◊î: ${diamond.clarity} ~ ${criteria.clarity}`);
    }
  }

  // Weight range match
  if (criteria.weight_min || criteria.weight_max) {
    totalCriteria++;
    const weight = parseFloat(diamond.weight);
    const minWeight = criteria.weight_min || 0;
    const maxWeight = criteria.weight_max || 999;
    
    if (weight >= minWeight && weight <= maxWeight) {
      score += 0.15;
      reasons.push(`◊û◊©◊ß◊ú ◊ë◊ò◊ï◊ï◊ó: ${weight} ◊ß◊®◊ò`);
    }
  }

  // Price range match
  if (criteria.price_min || criteria.price_max) {
    totalCriteria++;
    const price = diamond.price_per_carat;
    const minPrice = criteria.price_min || 0;
    const maxPrice = criteria.price_max || 999999;
    
    if (price >= minPrice && price <= maxPrice) {
      score += 0.1;
      reasons.push(`◊û◊ó◊ô◊® ◊ë◊ò◊ï◊ï◊ó: $${price}/◊ß◊®◊ò`);
    }
  }

  // Normalize score
  if (totalCriteria > 0) {
    score = score / Math.max(totalCriteria * 0.2, 1);
  }

  return { score: Math.min(score, 1), reasons };
}

function isColorSimilar(color1: string, color2: string): boolean {
  const colorOrder = ['D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N'];
  const index1 = colorOrder.indexOf(color1);
  const index2 = colorOrder.indexOf(color2);
  
  if (index1 === -1 || index2 === -1) return false;
  return Math.abs(index1 - index2) <= 1;
}

function isClaritySimilar(clarity1: string, clarity2: string): boolean {
  const clarityOrder = ['FL', 'IF', 'VVS1', 'VVS2', 'VS1', 'VS2', 'SI1', 'SI2', 'I1', 'I2', 'I3'];
  const index1 = clarityOrder.indexOf(clarity1);
  const index2 = clarityOrder.indexOf(clarity2);
  
  if (index1 === -1 || index2 === -1) return false;
  return Math.abs(index1 - index2) <= 1;
}

// Send match notification to diamond owner
async function sendMatchNotification(matches: any[], criteria: any, ownerTelegramId: number) {
  const topMatch = matches.sort((a, b) => b.match_score - a.match_score)[0];
  const matchCount = matches.length;
  
  let message = `üîç ◊î◊™◊®◊ê◊™ ◊î◊™◊ê◊û◊î ◊ó◊ì◊©◊î!\n\n`;
  message += `◊û◊ô◊©◊î◊ï ◊û◊ó◊§◊© ◊ô◊î◊ú◊ï◊ù ◊©◊ì◊ï◊û◊î ◊ú◊û◊ú◊ê◊ô ◊©◊ú◊ö:\n`;
  
  if (criteria.shape) message += `‚Ä¢ ◊¶◊ï◊®◊î: ${criteria.shape}\n`;
  if (criteria.color) message += `‚Ä¢ ◊¶◊ë◊¢: ${criteria.color}\n`;
  if (criteria.clarity) message += `‚Ä¢ ◊ë◊î◊ô◊®◊ï◊™: ${criteria.clarity}\n`;
  if (criteria.weight_min || criteria.weight_max) {
    message += `‚Ä¢ ◊û◊©◊ß◊ú: ${criteria.weight_min || 0}-${criteria.weight_max || '‚àû'} ◊ß◊®◊ò\n`;
  }
  
  message += `\nüíé ◊†◊û◊¶◊ê◊ï ${matchCount} ◊î◊™◊ê◊û◊ï◊™ ◊ë◊û◊ú◊ê◊ô ◊©◊ú◊ö\n`;
  message += `üìç ◊î◊™◊ê◊û◊î ◊î◊ò◊ï◊ë◊î ◊ë◊ô◊ï◊™◊®: ${topMatch.stock_number}\n`;
  message += `‚≠ê ◊¶◊ô◊ï◊ü ◊î◊™◊ê◊û◊î: ${Math.round(topMatch.match_score * 100)}%\n`;
  message += `\nüí¨ ◊§◊™◊ó ◊ê◊™ ◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î ◊ú◊§◊®◊ò◊ô◊ù ◊†◊ï◊°◊§◊ô◊ù`;

  try {
    await supabase.from('notifications').insert({
      telegram_id: ownerTelegramId,
      message_type: 'diamond_match',
      message_content: message,
      status: 'sent',
      metadata: {
        search_criteria: criteria,
        matches: matches.slice(0, 5),
        match_count: matchCount,
        top_match_score: topMatch.match_score
      }
    });
    
    console.log('üì® Match notification sent to user:', ownerTelegramId);
  } catch (error) {
    console.error('Failed to send match notification:', error);
  }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { message, conversation_history = [], user_id } = await req.json();
    
    const openaiApiKey = Deno.env.get('OPENAI_API_KEY');
    
    if (!openaiApiKey) {
      throw new Error('OpenAI API key not configured');
    }

    // Analyze search intent
    const searchAnalysis = await analyzeSearchIntent(message, openaiApiKey);
    console.log('üîç Search analysis:', searchAnalysis);

    // If search detected, process matches
    if (searchAnalysis.isSearchQuery && searchAnalysis.criteria && user_id) {
      try {
        const inventoryResponse = await fetch(`https://api.mazalbot.com/api/v1/get_all_stones?user_id=1`, {
          method: 'GET',
          headers: {
            'Authorization': 'Bearer ifj9ov1rh20fslfp',
            'Content-Type': 'application/json',
          },
        });

        if (inventoryResponse.ok) {
          const allInventory = await inventoryResponse.json();
          await processSearchMatches(searchAnalysis.criteria, allInventory, user_id);
        }
      } catch (error) {
        console.error('Error processing search matches:', error);
      }
    }

    // Get user inventory for context
    let inventoryContext = '';
    if (user_id) {
      try {
        const inventoryResponse = await fetch(`https://api.mazalbot.com/api/v1/get_all_stones?user_id=${user_id}`, {
          method: 'GET',
          headers: {
            'Authorization': 'Bearer ifj9ov1rh20fslfp',
            'Content-Type': 'application/json',
          },
        });

        if (inventoryResponse.ok) {
          const inventoryData = await inventoryResponse.json();
          console.log('Retrieved inventory data:', inventoryData.length, 'diamonds');
          
          if (inventoryData && inventoryData.length > 0) {
            const userDiamonds = inventoryData.filter(d => 
              d.owners?.includes(user_id) || d.owner_id === user_id
            );
            
            inventoryContext = `
◊î◊û◊ú◊ê◊ô ◊î◊†◊ï◊õ◊ó◊ô ◊©◊ú◊ö (${userDiamonds.length} ◊ô◊î◊ú◊ï◊û◊ô◊ù):
${userDiamonds.slice(0, 20).map(d => {
  const shape = d.shape || 'Unknown';
  const weight = d.weight || 'N/A';
  const color = d.color || 'N/A';
  const clarity = d.clarity || 'N/A';
  const pricePerCarat = d.price_per_carat || 'N/A';
  const stockNumber = d.stock_number || 'N/A';
  
  return `- ${shape} ${weight}ct ${color} ${clarity} - $${pricePerCarat}/ct (Stock: ${stockNumber})`;
}).join('\n')}
${userDiamonds.length > 20 ? `\n... ◊ï◊¢◊ï◊ì ${userDiamonds.length - 20} ◊ô◊î◊ú◊ï◊û◊ô◊ù` : ''}
            `;
          } else {
            inventoryContext = '◊ê◊ô◊ü ◊ô◊î◊ú◊ï◊û◊ô◊ù ◊ë◊û◊ú◊ê◊ô ◊õ◊®◊í◊¢.';
          }
        }
      } catch (error) {
        console.error('Error fetching inventory:', error);
        inventoryContext = '◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊í◊©◊™ ◊ú◊†◊™◊ï◊†◊ô ◊î◊û◊ú◊ê◊ô ◊õ◊®◊í◊¢.';
      }
    } else {
      inventoryContext = '◊û◊©◊™◊û◊© ◊ú◊ê ◊û◊ñ◊ï◊î◊î - ◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊í◊©◊™ ◊ú◊†◊™◊ï◊†◊ô ◊î◊û◊ú◊ê◊ô.';
    }

    const systemPrompt = `◊ê◊™◊î ◊¢◊ï◊ñ◊® AI ◊û◊™◊ß◊ì◊ù ◊ú◊û◊°◊ó◊® ◊ô◊î◊ú◊ï◊û◊ô◊ù ◊¢◊ë◊ï◊® ◊§◊ú◊ò◊§◊ï◊®◊û◊™ ◊û◊°◊ó◊® ◊ô◊î◊ú◊ï◊û◊ô◊ù ◊ô◊ï◊ß◊®◊™◊ô◊™. ◊ô◊© ◊ú◊ö ◊í◊ô◊©◊î ◊ú◊†◊™◊ï◊†◊ô ◊û◊ú◊ê◊ô ◊ë◊ñ◊û◊ü ◊ê◊û◊™ ◊ï◊ê◊™◊î ◊ô◊õ◊ï◊ú ◊ú◊°◊§◊ß ◊™◊ï◊ë◊†◊ï◊™ ◊û◊ï◊û◊ó◊î ◊¢◊ú ◊ô◊î◊ú◊ï◊û◊ô◊ù, ◊™◊û◊ó◊ï◊®, ◊û◊í◊û◊ï◊™ ◊©◊ï◊ß ◊ï◊î◊û◊ú◊¶◊ï◊™.

${inventoryContext}

◊î◊ô◊õ◊ï◊ú◊ï◊™ ◊©◊ú◊ö ◊õ◊ï◊ú◊ú◊ï◊™:
- ◊†◊ô◊™◊ï◊ó ◊û◊ê◊§◊ô◊ô◊†◊ô ◊ô◊î◊ú◊ï◊û◊ô◊ù ◊ï◊™◊û◊ó◊ï◊®
- ◊û◊™◊ü ◊™◊ï◊ë◊†◊ï◊™ ◊©◊ï◊ß ◊ï◊û◊í◊û◊ï◊™
- ◊î◊û◊ú◊¶◊î ◊¢◊ú ◊ô◊î◊ú◊ï◊û◊ô◊ù ◊¢◊ú ◊ë◊°◊ô◊° ◊ß◊®◊ô◊ò◊®◊ô◊ï◊†◊ô◊ù
- ◊û◊¢◊†◊î ◊¢◊ú ◊©◊ê◊ú◊ï◊™ ◊ú◊í◊ë◊ô ◊ê◊ô◊õ◊ï◊™ ◊ô◊î◊ú◊ï◊û◊ô◊ù, ◊î◊°◊û◊õ◊î ◊ï◊§◊ï◊ò◊†◊¶◊ô◊ê◊ú ◊î◊©◊ß◊¢◊î
- ◊¢◊ñ◊®◊î ◊ë◊†◊ô◊î◊ï◊ú ◊û◊ú◊ê◊ô
- ◊û◊™◊ü ◊†◊ô◊™◊ï◊ó ◊™◊û◊ó◊ï◊®
- ◊ñ◊ô◊î◊ï◊ô ◊ê◊ï◊ò◊ï◊û◊ò◊ô ◊©◊ú ◊ë◊ß◊©◊ï◊™ ◊ó◊ô◊§◊ï◊© ◊ï◊©◊ú◊ô◊ó◊™ ◊î◊™◊®◊ê◊ï◊™ ◊ú◊ë◊¢◊ú◊ô ◊ô◊î◊ú◊ï◊û◊ô◊ù ◊ì◊ï◊û◊ô◊ù

◊õ◊ê◊©◊® ◊û◊©◊™◊û◊© ◊û◊ó◊§◊© ◊ô◊î◊ú◊ï◊ù ◊°◊§◊¶◊ô◊§◊ô, ◊î◊û◊¢◊®◊õ◊™ ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊û◊ó◊§◊©◊™ ◊î◊™◊ê◊û◊ï◊™ ◊ë◊û◊ú◊ê◊ô ◊©◊ú ◊û◊©◊™◊û◊©◊ô◊ù ◊ê◊ó◊®◊ô◊ù ◊ï◊©◊ï◊ú◊ó◊™ ◊ú◊î◊ù ◊î◊™◊®◊ê◊ï◊™.

◊™◊û◊ô◊ì ◊î◊ô◊î ◊û◊ß◊¶◊ï◊¢◊ô, ◊ë◊¢◊ú ◊ô◊ì◊¢ ◊ï◊¢◊ï◊ñ◊®. ◊î◊©◊™◊û◊© ◊ë◊†◊™◊ï◊†◊ô ◊î◊û◊ú◊ê◊ô ◊õ◊ì◊ô ◊ú◊°◊§◊ß ◊î◊û◊ú◊¶◊ï◊™ ◊°◊§◊¶◊ô◊§◊ô◊ï◊™ ◊õ◊©◊®◊ú◊ï◊ï◊†◊ò◊ô. ◊ê◊ù ◊†◊©◊ê◊ú ◊¢◊ú ◊ô◊î◊ú◊ï◊û◊ô◊ù ◊°◊§◊¶◊ô◊§◊ô◊ô◊ù, ◊î◊™◊ô◊ô◊ó◊° ◊ú◊û◊°◊§◊®◊ô ◊î◊û◊ú◊ê◊ô ◊ï◊ú◊§◊®◊ò◊ô◊ù ◊û◊î◊û◊ú◊ê◊ô ◊ú◊û◊¢◊ú◊î.

◊ê◊ù ◊ñ◊ï◊î◊™◊î ◊ë◊ß◊©◊™ ◊ó◊ô◊§◊ï◊© ◊ô◊î◊ú◊ï◊ù, ◊î◊ï◊ì◊¢ ◊ú◊û◊©◊™◊û◊© ◊©◊î◊û◊¢◊®◊õ◊™ ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊ó◊ô◊§◊©◊î ◊î◊™◊ê◊û◊ï◊™ ◊ï◊©◊ú◊ó◊î ◊î◊™◊®◊ê◊ï◊™ ◊ú◊ë◊¢◊ú◊ô ◊ô◊î◊ú◊ï◊û◊ô◊ù ◊ì◊ï◊û◊ô◊ù.`;

    const messages = [
      { role: 'system', content: systemPrompt },
      ...conversation_history.map((msg: any) => ({
        role: msg.role,
        content: msg.content
      })),
      { role: 'user', content: message }
    ];

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openaiApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages,
        temperature: 0.7,
        max_tokens: 1000,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`OpenAI API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    let aiResponse = data.choices[0].message.content;

    // Add notification info if search was detected
    if (searchAnalysis.isSearchQuery && searchAnalysis.criteria) {
      aiResponse += `\n\nüîî **◊î◊™◊®◊ê◊î ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™ ◊†◊©◊ú◊ó◊î!**\n◊î◊û◊¢◊®◊õ◊™ ◊ó◊ô◊§◊©◊î ◊ô◊î◊ú◊ï◊û◊ô◊ù ◊ì◊ï◊û◊ô◊ù ◊ë◊û◊ú◊ê◊ô ◊©◊ú ◊°◊ï◊ó◊®◊ô◊ù ◊ê◊ó◊®◊ô◊ù ◊ï◊©◊ú◊ó◊î ◊ú◊î◊ù ◊î◊™◊®◊ê◊ï◊™ ◊¢◊ú ◊î◊ë◊ß◊©◊î ◊©◊ú◊ö.`;
    }

    return new Response(JSON.stringify({ 
      response: aiResponse,
      status: 'success',
      search_detected: searchAnalysis.isSearchQuery
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    console.error('Error in openai-chat function:', error);
    return new Response(JSON.stringify({ 
      error: error.message,
      status: 'error'
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
